<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>正则 on Mgso</title>
    <link>https://mgso.site/tags/%E6%AD%A3%E5%88%99/</link>
    <description>Recent content in 正则 on Mgso</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <atom:link href="https://mgso.site/tags/%E6%AD%A3%E5%88%99/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>js正则表达式分组() 不捕获(?:) 断言</title>
      <link>https://mgso.site/front-end/reg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://mgso.site/front-end/reg/</guid>
      <description>分组 分组在正则中用()表示，分组的作用有两个：
1.将某些规律看成是一组，然后进行组级别的重复，可以得到意想不到的效果。
2.分组之后，可以通过后向引用简化表达式（\1 或者$1）。
eg:
先来看第一个作用，对于IP地址的匹配，简单的可以写为如下形式：
1 /\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}/ 但仔细观察，我们可以发现一定的规律，可以把.\d{1,3}看成一个整体，也就是把他们看成一组，再把这个组重复3次即可。表达式如下：
1 /\d{1,3}(.\d{1,3}){3}/ 再来看第二个作用，就拿匹配&amp;lt;title&amp;gt;xxx&amp;lt;/title&amp;gt;标签来说，简单的正则可以这样写：
1 /&amp;lt;title&amp;gt;.*&amp;lt;\/title&amp;gt;/ 可以看出，上边表达式中有两个title，完全一样，其实可以通过分组简写。表达式如下：
1 /&amp;lt;(title)&amp;gt;.*&amp;lt;\/\1&amp;gt;/ 对于分组而言，整个表达式永远算作第0组 在上述例中，第0组是&amp;lt;(title)&amp;gt;.*&amp;lt;/\1&amp;gt;，然后从左到右，依次为分组编号，因此，(title)是第1组 :::warning 注意 用\1这种语法，可以引用某组的文本内容，但不能引用正则表达式。 ::: 例如刚刚的IP地址正则表达式为\d{1,3}(.\d{1,3}){3}，里边的\d{1,3}重复了两次，如果利用后向引用简化，表达式如下
1 /(\d{1,3})(.\1){3}/ 经过实际测试，会发现这样写是错误的，为什么呢？
后向引用，引用的仅仅是文本内容，而不是正则表达式！
也就是说，组中的内容一旦匹配成功，后向引用，引用的就是匹配成功后的内容，引用的是结果，而不是表达式。
因此，(\d{1,3})(.\1){3}这个表达式实际上匹配的是四个数都相同的IP地址，比如：123.123.123.123。
不捕获 不捕获其实就是在分组的前边加上?:，可以在不需要捕获分组的表达式中使用，加快表达式执行速度。
就拿匹配xxx标签来说，通过分组可以简写为
1 /&amp;lt;(title)&amp;gt;.*&amp;lt;\/\1&amp;gt; / 但是如果是(?:title),则\1就不能捕获到这个子组了，只能捕获第一个出现的非?:的分组作为\1
::: tip 提示 (?:title)本身会在完整匹配中，只是不在子组中，注意和断言的区别 :::
断言 所谓断言，就是指明某个字符串前边或者后边，将会出现满足某种规律的字符串 就拿匹配&amp;lt;title&amp;gt;xxx&amp;lt;/title&amp;gt;标签来说 我们想要的是xxx，它没有规律，但是它前边肯定会有&amp;lt;title&amp;gt;,后边肯定会有&amp;lt;/title&amp;gt;，这就足够了 想指定xxx前肯定会出现&amp;lt;title&amp;gt;，就用正后发断言，表达式：
1 /(?&amp;lt;=&amp;lt;title&amp;gt;).*/ 想指定xxx后边肯定会出现，就用正先行断言，表达式：
1 /.*(?=&amp;lt;\/title&amp;gt;)/ 两个加在一起，就是
1 /(?&amp;lt;=&amp;lt;title&amp;gt;).*(?=&amp;lt;\/title&amp;gt;)/ 对正后发和正先行的解释：
其实掌握了规律，就很简单了，无论是先行还是后发，都是相对于xxx而言的，也就是相对于目标字符串而言。
假如目标字符串后边有条件，可以理解为目标字符串在前，就用先行断言，放在目标字符串之后。
假如目标字符串前边有条件，可以理解为目标字符串在后，就用后发断言，放在目标字符串之前。
假如指定满足某个条件，就是正。
假如指定不满足某个条件，就是负。
断言只是条件，帮你找到真正需要的字符串，本身并不会匹配！
！表示正好相反的意思，就是把=换成了！，看表格解释，X代表字符
表达式 释义 (?=X ) 零宽度正先行断言。仅当子表达式 X 在 此位置的右侧匹配时才继续匹配。例如，\w+(?</description>
    </item>
  </channel>
</rss>
