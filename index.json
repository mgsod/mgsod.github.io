[{"content":"最近电信扫描家宽web端口、pcdn有点严格，不少网友都被下通知整改，不然关闭套餐。有了公网ip确实方便很多，虽然是动态的但依旧可以用各种ddns 服务绑定域名。但问题又来了，也有网友说电信查到未备案的域名用了ddns解析到家宽ip，也不行！也要整改！\n公网ip资源可贵啊，为了避免各种理由被关套餐或者导致公网ip业务没了就可惜了。毕竟现在可不是说工信部投诉就能给你ip的。得100块钱一个月 最近查的严，那就关掉ddns服务，和一切web端口了。但出门在外总有需求会用到家里的各种服务，所以这里选择搭建wireguard回家，下面介绍整个流程\n1、关于wireguard WireGuard 是一个易于配置、快速且安全的开源 VPN，它利用了最新的加密技术。目的是提供一种更快、更简单、更精简的通用 VPN，它可以轻松地在树莓派这类低端设备到高端服务器上部署。\n","permalink":"https://mgso.site/linux/wireguard/","summary":"最近电信扫描家宽web端口、pcdn有点严格，不少网友都被下通知整改，不然关闭套餐。有了公网ip确实方便很多，虽然是动态的但依旧可以用各种ddns 服务绑定域名。但问题又来了，也有网友说电信查到未备案的域名用了ddns解析到家宽ip，也不行！也要整改！\n公网ip资源可贵啊，为了避免各种理由被关套餐或者导致公网ip业务没了就可惜了。毕竟现在可不是说工信部投诉就能给你ip的。得100块钱一个月 最近查的严，那就关掉ddns服务，和一切web端口了。但出门在外总有需求会用到家里的各种服务，所以这里选择搭建wireguard回家，下面介绍整个流程\n1、关于wireguard WireGuard 是一个易于配置、快速且安全的开源 VPN，它利用了最新的加密技术。目的是提供一种更快、更简单、更精简的通用 VPN，它可以轻松地在树莓派这类低端设备到高端服务器上部署。","title":"群晖Nas搭建wireguard回家"},{"content":" Vue中以指令方式 1 2 3 import Vue from \u0026#39;vue\u0026#39; import dragCellResize from \u0026#39;drag-cell-resize\u0026#39; Vue.use(dragCellResize); Vue中以 new DragCellResize()来调用 1 2 3 4 5 6 7 8 import {DragCellResize} from \u0026#39;drag-cell-resize\u0026#39; export default { mounted(){ new DragCellResize(this.$refs[\u0026#39;table\u0026#39;],()=\u0026gt;{},false) // DragCellResize三个参数，第一个是要绑定的dom对象， // 第二个为回调函数，第三个为是否自定义拖拽行为 } } Demo 1 默认拖拽行为 仅仅只需要在table上绑定v-drag-cell-resize,指令会自动完成拖拽列宽操作\n::: demo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;table v-drag-cell-resize\u0026gt; \u0026lt;colgroup\u0026gt; \u0026lt;col v-for=\u0026#34;item in 5\u0026#34; width=\u0026#34;120px\u0026#34;\u0026gt; \u0026lt;/colgroup\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;First Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Last Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Points\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Sec\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;item in 5\u0026#34;\u0026gt; \u0026lt;td\u0026gt;Jill\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Smith\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;18\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Man\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;table v-drag-cell-resize\u0026gt; \u0026lt;colgroup\u0026gt; \u0026lt;col v-for=\u0026#34;item in 6\u0026#34; width=\u0026#34;100px\u0026#34;\u0026gt; \u0026lt;/colgroup\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th colspan=\u0026#34;2\u0026#34;\u0026gt;A\u0026lt;/th\u0026gt; \u0026lt;th colspan=\u0026#34;3\u0026#34;\u0026gt;B\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;C\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;A1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;A2\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;B1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;B2\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;B3\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;C\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;item in 6\u0026#34;\u0026gt; \u0026lt;td\u0026gt;Jill\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Smith\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;18\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Man\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Man\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; th,td{ box-sizing: border-box; } \u0026lt;/style\u0026gt; :::\n2 添加回调函数 v-drag-cell-resizez接受一个值（Function）作为拖拽结束后的回调，再拖拽完成后会自动执行该函数\n回调参数\nevent:鼠标事件参数 dragResize:拖拽的实例对象，其中包含offsetX(此次拖拽的偏移量)，cell（当前拖拽的单元格） ::: demo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;template\u0026gt; \u0026lt;table v-drag-cell-resize=\u0026#34;dragEnd\u0026#34;\u0026gt; \u0026lt;colgroup\u0026gt; \u0026lt;col v-for=\u0026#34;item in 5\u0026#34; width=\u0026#34;120px\u0026#34;\u0026gt; \u0026lt;/colgroup\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;First Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Last Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Points\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Sec\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;item in 5\u0026#34;\u0026gt; \u0026lt;td\u0026gt;Jill\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Smith\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;18\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Man\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;div\u0026gt;拖拽偏移量：{{offsetX}}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data: () =\u0026gt; ({ message: \u0026#34;Hello World\u0026#34;,offsetX:0}), methods: { dragEnd(e,dragCellResize) { let{offsetX,cell} = dragCellResize; this.offsetX = offsetX; console.log(e,offsetX,cell); }, }, }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; th,td{ box-sizing: border-box; } \u0026lt;/style\u0026gt; :::\n3 自定义拖拽行为 v-drag-cell-resize.custom=\u0026quot;dragEnd\u0026quot;\n给指令传入.custom修饰符将会由dragEnd接管拖拽行为，这时候指令不会自动设置列宽，而是由传入的函数自行决定。 必要的拖拽参数在dragEnd的回调参数中可以取到.\ndragCellResize对象中的cell为当前拖拽的单元格，通过修改该单元格属性来达到想要的结果\neg1：每次拖拽2倍宽度，设置单元格背景色 ::: demo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026lt;template\u0026gt; \u0026lt;table v-drag-cell-resize.custom=\u0026#34;dragEnd\u0026#34;\u0026gt; \u0026lt;colgroup\u0026gt; \u0026lt;col v-for=\u0026#34;item in 6\u0026#34; width=\u0026#34;100px\u0026#34;\u0026gt; \u0026lt;/colgroup\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th colspan=\u0026#34;2\u0026#34;\u0026gt;A\u0026lt;/th\u0026gt; \u0026lt;th colspan=\u0026#34;3\u0026#34;\u0026gt;B\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;C\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr \u0026gt; \u0026lt;th\u0026gt;A1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;A2\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;B1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;B2\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;B3\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;C\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;item in 6\u0026#34;\u0026gt; \u0026lt;td\u0026gt;Jill\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Smith\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;18\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Man\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Man\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data: () =\u0026gt; ({ message: \u0026#34;Hello World\u0026#34; }), methods: { dragEnd(e,dragCellResize) { console.log(dragCellResize) let{offsetX,cell} = dragCellResize cell.style.width = cell.offsetWidth + (offsetX*2)+\u0026#39;px\u0026#39;; cell.style.backgroundColor = \u0026#39;#409eff\u0026#39; }, }, }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; th,td{ box-sizing: border-box; } \u0026lt;/style\u0026gt; :::\neg2：thead由另一个table组成。 在某些情况下，为了固定表头，我们会时使用另一个table来做表头。对于这种情况，使用.custom修饰符接管拖拽行为，然后自行设置列宽\n::: demo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 \u0026lt;template\u0026gt; \u0026lt;div ref=\u0026#34;table\u0026#34; class=\u0026#34;table\u0026#34; v-drag-cell-resize.custom=\u0026#34;dragEnd\u0026#34;\u0026gt; \u0026lt;table class=\u0026#34;thead\u0026#34; style=\u0026#34;margin-bottom: -17px\u0026#34;\u0026gt; \u0026lt;colgroup\u0026gt; \u0026lt;col v-for=\u0026#34;item in 5\u0026#34; :data-key=\u0026#34;item\u0026#34; width=\u0026#34;120px\u0026#34;\u0026gt; \u0026lt;/colgroup\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;First Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Last Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Points\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Sec\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;table ref=\u0026#34;tbody\u0026#34;\u0026gt; \u0026lt;colgroup\u0026gt; \u0026lt;col v-for=\u0026#34;item in 5\u0026#34; :data-key=\u0026#34;item\u0026#34; width=\u0026#34;120px\u0026#34;\u0026gt; \u0026lt;/colgroup\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;item in 5\u0026#34;\u0026gt; \u0026lt;td\u0026gt;Adam\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Johnson\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;67\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;18\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Man\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data: () =\u0026gt; ({ message: \u0026#34;Hello World\u0026#34; }), methods: { dragEnd(e,dragCellResize) { let{offsetX,cell} = dragCellResize; // 获取当前单元格个拖拽的索引 let cellIndex = [].indexOf.call(cell.parentElement.children,cell)+1; this.$refs[\u0026#39;table\u0026#39;].querySelectorAll(`col[data-key=\u0026#39;${cellIndex}\u0026#39;]`).forEach(item =\u0026gt;{ item.width = `${parseFloat(item.width) + offsetX}px` }) }, }, }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; th,td{ box-sizing: border-box; font-size: 14px; padding: 8px 20px; } \u0026lt;/style\u0026gt; ::: 此例中的表格由两个table组成，包裹在div中。这时，可以将v-drag-cell-resize指令绑定在div上面. 然后从dragEnd回调参数中拿到当前单元格和offsetX,随即可以通过单元格获取到索引。然后再统一设置col的width属性来更新两个表格中的列宽\n","permalink":"https://mgso.site/front-end/dragcell/","summary":"Vue中以指令方式 1 2 3 import Vue from \u0026#39;vue\u0026#39; import dragCellResize from \u0026#39;drag-cell-resize\u0026#39; Vue.use(dragCellResize); Vue中以 new DragCellResize()来调用 1 2 3 4 5 6 7 8 import {DragCellResize} from \u0026#39;drag-cell-resize\u0026#39; export default { mounted(){ new DragCellResize(this.$refs[\u0026#39;table\u0026#39;],()=\u0026gt;{},false) // DragCellResize三个参数，第一个是要绑定的dom对象， // 第二个为回调函数，第三个为是否自定义拖拽行为 } } Demo 1 默认拖拽行为 仅仅只需要在table上绑定v-drag-cell-resize,指令会自动完成拖拽列宽操作\n::: demo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;table v-drag-cell-resize\u0026gt; \u0026lt;colgroup\u0026gt; \u0026lt;col v-for=\u0026#34;item in 5\u0026#34; width=\u0026#34;120px\u0026#34;\u0026gt; \u0026lt;/colgroup\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;First Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Last Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Points\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Sec\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;item in 5\u0026#34;\u0026gt; \u0026lt;td\u0026gt;Jill\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Smith\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;18\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Man\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;table v-drag-cell-resize\u0026gt; \u0026lt;colgroup\u0026gt; \u0026lt;col v-for=\u0026#34;item in 6\u0026#34; width=\u0026#34;100px\u0026#34;\u0026gt; \u0026lt;/colgroup\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th colspan=\u0026#34;2\u0026#34;\u0026gt;A\u0026lt;/th\u0026gt; \u0026lt;th colspan=\u0026#34;3\u0026#34;\u0026gt;B\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;C\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;A1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;A2\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;B1\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;B2\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;B3\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;C\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;item in 6\u0026#34;\u0026gt; \u0026lt;td\u0026gt;Jill\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Smith\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;18\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Man\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Man\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; th,td{ box-sizing: border-box; } \u0026lt;/style\u0026gt; :::","title":"vue拖拽表格单元格指令"},{"content":"目前对于d3.js的捆图(bundle),网上的资料都是d3(v3)版本的.但是介于现在d3.js已经是5.x版本了,所以针对v4改版后 对捆图升级.\n效果图 与v3版本的不同 d3.layout.cluster() =\u0026gt; d3.cluster()\ncluster.nodes() =\u0026gt; cluster(d3.hierarchy(cities)).leaves()\n其中leaves() 作用是返回叶节点数组，叶节点是没有孩子节点的节点。\nd3.layout.bundle() =\u0026gt; node.path(target)\nd3.scale.category10c() =\u0026gt; d3.scaleOrdinal(d3.schemeCategory10)\n文档参考 d3js.org.cn/api\nv3 与 v4\n代码示例: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;捆图\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .node circle { stroke: black; stroke-width: 1px; } .node text { font-size: 12px; font-family: simsun; } .link { fill: none; stroke: black; stroke-opacity: .5; stroke-width: 2px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;https://d3js.org/d3.v5.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var width = 500;\t//SVG绘制区域的宽度 var height = 500;\t//SVG绘制区域的高度 var svg = d3.select(\u0026#34;body\u0026#34;)\t//选择\u0026lt;body\u0026gt; .append(\u0026#34;svg\u0026#34;)\t//在\u0026lt;body\u0026gt;中添加\u0026lt;svg\u0026gt; .attr(\u0026#34;width\u0026#34;, width)\t//设定\u0026lt;svg\u0026gt;的宽度属性 .attr(\u0026#34;height\u0026#34;, height);//设定\u0026lt;svg\u0026gt;的高度属性 // 城市列表 var cities = { name: \u0026#34;\u0026#34;, children: [ {name: \u0026#34;北京\u0026#34;}, {name: \u0026#34;上海\u0026#34;}, {name: \u0026#34;杭州\u0026#34;}, {name: \u0026#34;广州\u0026#34;}, {name: \u0026#34;桂林\u0026#34;}, {name: \u0026#34;昆明\u0026#34;}, {name: \u0026#34;成都\u0026#34;}, {name: \u0026#34;西安\u0026#34;}, {name: \u0026#34;太原\u0026#34;} ] }; var railway = [ {source: \u0026#34;北京\u0026#34;, target: \u0026#34;上海\u0026#34;}, {source: \u0026#34;北京\u0026#34;, target: \u0026#34;广州\u0026#34;}, {source: \u0026#34;北京\u0026#34;, target: \u0026#34;杭州\u0026#34;}, {source: \u0026#34;北京\u0026#34;, target: \u0026#34;西安\u0026#34;}, {source: \u0026#34;北京\u0026#34;, target: \u0026#34;成都\u0026#34;}, {source: \u0026#34;北京\u0026#34;, target: \u0026#34;太原\u0026#34;}, {source: \u0026#34;北京\u0026#34;, target: \u0026#34;桂林\u0026#34;}, {source: \u0026#34;北京\u0026#34;, target: \u0026#34;昆明\u0026#34;}, {source: \u0026#34;北京\u0026#34;, target: \u0026#34;成都\u0026#34;}, {source: \u0026#34;上海\u0026#34;, target: \u0026#34;杭州\u0026#34;}, {source: \u0026#34;昆明\u0026#34;, target: \u0026#34;成都\u0026#34;}, {source: \u0026#34;西安\u0026#34;, target: \u0026#34;太原\u0026#34;} ]; var cluster = d3.cluster() .size([360, width / 2 - 100]); var nodes = cluster(d3.hierarchy(cities)).leaves(); function map (nodes, links) { var hash = []; for (var i = 0; i \u0026lt; nodes.length; i++) { hash[nodes[i].data.name] = nodes[i]; } var resultLinks = []; for (var i = 0; i \u0026lt; links.length; i++) { //d3 v4后用node.path(target)来计算两个点的距离 //返回一个从node-\u0026gt;parent-\u0026gt;target的数组路径 resultLinks.push(hash[links[i].source].path(hash[links[i].target])) } return resultLinks; } var links = map(nodes, railway); var gBundle = svg.append(\u0026#34;g\u0026#34;) .attr(\u0026#34;transform\u0026#34;, \u0026#34;translate(\u0026#34; + (width / 2) + \u0026#34;,\u0026#34; + (height / 2) + \u0026#34;)\u0026#34;); //线段生成器 var line = d3.radialLine() .curve(d3.curveBundle.beta(0.85)) .radius(function (d) { return d.y; }) .angle(function (d) { return d.x / 180 * Math.PI; }); //添加线条 gBundle.selectAll(\u0026#34;.link\u0026#34;) .data(links) .enter() .append(\u0026#34;path\u0026#34;) .attr(\u0026#34;class\u0026#34;, \u0026#34;link\u0026#34;) .attr(\u0026#34;d\u0026#34;, line); //颜色生成器 var color = d3.scaleOrdinal(d3.schemeCategory10); //添加节点 var node = gBundle.selectAll(\u0026#34;.node\u0026#34;) .data(nodes.filter(function (d) { return !d.children; })) .enter() .append(\u0026#34;g\u0026#34;) .attr(\u0026#34;class\u0026#34;, \u0026#34;node\u0026#34;) .attr(\u0026#34;transform\u0026#34;, function (d) { return \u0026#34;rotate(\u0026#34; + (d.x - 90) + \u0026#34;)translate(\u0026#34; + d.y + \u0026#34;)\u0026#34; + \u0026#34;rotate(\u0026#34; + (90 - d.x) + \u0026#34;)\u0026#34;; }); //圆 node.append(\u0026#34;circle\u0026#34;) .attr(\u0026#34;r\u0026#34;, 20) .style(\u0026#34;fill\u0026#34;, function (d, i) { return color(i); }); //文本信息 node.append(\u0026#34;text\u0026#34;) .attr(\u0026#34;dy\u0026#34;, \u0026#34;.2em\u0026#34;) .style(\u0026#34;text-anchor\u0026#34;, \u0026#34;middle\u0026#34;) .text(function (d) { return d.data.name; }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://mgso.site/front-end/d3-bundle/","summary":"目前对于d3.js的捆图(bundle),网上的资料都是d3(v3)版本的.但是介于现在d3.js已经是5.x版本了,所以针对v4改版后 对捆图升级.\n效果图 与v3版本的不同 d3.layout.cluster() =\u0026gt; d3.cluster()\ncluster.nodes() =\u0026gt; cluster(d3.hierarchy(cities)).leaves()\n其中leaves() 作用是返回叶节点数组，叶节点是没有孩子节点的节点。\nd3.layout.bundle() =\u0026gt; node.path(target)\nd3.scale.category10c() =\u0026gt; d3.scaleOrdinal(d3.schemeCategory10)\n文档参考 d3js.org.cn/api\nv3 与 v4\n代码示例: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;捆图\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .","title":"d3.js的捆图"},{"content":" 最近做私单遇到一个问题.客户觉得上传一张手机上的图片速度很慢.有时候甚至慢到timeout.于是要求前端做压缩 寻找了很多解决方案,大多数都是以舍弃高宽为基础从而实现压缩.但是这种做法无疑让图片受损.且若是身份证之类的证件 图片用这种压缩方式更不可取.于是乎找到一个近乎完美的解决方案.压缩图片质量而不是高宽\n1 图片压缩\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * @param path 文件路径 * @param options 包含宽,高,质量 * @param callback 图片压缩后执行的回调函数 */ function canvasDataURL(path, options, callback) { var img = new Image(); img.src = path; img.onload = function () { var that = this; // 默认按比例压缩 var w = that.width, h = that.height, scale = w / h; w = options.width || w; h = options.height || (w / scale); //默认等比压缩 var quality = 0.7; // 默认图片质量为0.7 //生成canvas var canvas = document.createElement(\u0026#39;canvas\u0026#39;); var ctx = canvas.getContext(\u0026#39;2d\u0026#39;); // 创建属性节点 var anw = document.createAttribute(\u0026#34;width\u0026#34;); anw.nodeValue = w; var anh = document.createAttribute(\u0026#34;height\u0026#34;); anh.nodeValue = h; canvas.setAttributeNode(anw); canvas.setAttributeNode(anh); ctx.drawImage(that, 0, 0, w, h); // 图像质量 if (options.quality \u0026amp;\u0026amp; options.quality \u0026lt;= 1 \u0026amp;\u0026amp; options.quality \u0026gt; 0) { quality = options.quality; } // quality值越小，所绘制出的图像越模糊 var base64 = canvas.toDataURL(\u0026#39;image/jpeg\u0026#39;, quality); // 回调函数返回base64的值 callback(base64); } } 其实从代码中我们可以显而易见地知道,压缩图片的整个过程其实就是将一张图片按照原有高宽用canvas进行重绘.并按照quality将canvas转成 base64输出\n2 如何调用图片压缩函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * @param file 文件对象 * @param options 包含宽,高,质量 * @param callback */ function photoCompress(file, options, callback) { var ready = new FileReader(); //开始读取指定的Blob对象或File对象中的内容. //当读取操作完成时,readyState属性的值会成为DONE // 如果设置了onloadend事件处理程序,则调用之. //同时,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容. ready.readAsDataURL(file); ready.onload = function () { var path = this.result; canvasDataURL(path, options, callback) } } 这个函数是将一个图片对象通过FileReader对象加载,并将文件的path,options,callback传入canvasDataURL函数.\n3 base64转Blob\n1 2 3 4 5 6 7 8 function convertBase64UrlToBlob(urlData){ var arr = urlData.split(\u0026#39;,\u0026#39;), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while(n--){ u8arr[n] = bstr.charCodeAt(n); } return new Blob([u8arr], {type:mime}); } 我们知道,一般上传文件都是上传的文件流即Blod.那么通过canvasDataURL处理后我们还需要讲得到的base64转成可供上传的流\n3 完成整个压缩流程\n上面两个函数其实可以当做一个函数处理.但是由于FileReader对象的onload是一个异步过程.所以这里进行了拆分. photoCompress函数主要是将图片的路径获取出来,然后调用canvasDataURL对图片进行压缩\n那应用到实际场景中的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 var fileObj = document.getElementById(\u0026#34;file\u0026#34;).files[0]; // js 获取文件对象 var form = new FormData(); // FormData 对象 if(fileObj.size/1024 \u0026gt; 1025) { //大于1M，进行压缩上传 //这里我们仅对质量进行压缩,图片高宽默认等比 var compressOptions ={ quality: 0.2 } photoCompress(fileObj, compressOptions, function(base64Codes){ //console.log(\u0026#34;压缩后：\u0026#34; + base.length / 1024 + \u0026#34; \u0026#34; + base); var bl = convertBase64UrlToBlob(base64Codes); form.append(\u0026#34;file\u0026#34;, bl, \u0026#34;file_\u0026#34;+Date.parse(new Date())+\u0026#34;.jpg\u0026#34;); // 文件对象 /* 文件上传操作... $.ajax({ url:\u0026#39;xxx\u0026#39;, method:\u0026#39;POST\u0026#39;, data:form ... }) */ }); }else{ //小于等于1M 原图上传 form.append(\u0026#34;file\u0026#34;, fileObj); // 文件对象 /* 文件上传操作... $.ajax({ url:\u0026#39;xxx\u0026#39;, method:\u0026#39;POST\u0026#39;, data:form ... }) */ } 4 压缩效果\n图片对比 :\n文件大小对比 :\n从图中可以看出压缩的效果还是挺不错的.当然在上传速度上也有很客观的变化.\nEND\n","permalink":"https://mgso.site/front-end/zipimg/","summary":"最近做私单遇到一个问题.客户觉得上传一张手机上的图片速度很慢.有时候甚至慢到timeout.于是要求前端做压缩 寻找了很多解决方案,大多数都是以舍弃高宽为基础从而实现压缩.但是这种做法无疑让图片受损.且若是身份证之类的证件 图片用这种压缩方式更不可取.于是乎找到一个近乎完美的解决方案.压缩图片质量而不是高宽\n1 图片压缩\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * @param path 文件路径 * @param options 包含宽,高,质量 * @param callback 图片压缩后执行的回调函数 */ function canvasDataURL(path, options, callback) { var img = new Image(); img.src = path; img.","title":"js压缩图片"},{"content":"分组 分组在正则中用()表示，分组的作用有两个：\n1.将某些规律看成是一组，然后进行组级别的重复，可以得到意想不到的效果。\n2.分组之后，可以通过后向引用简化表达式（\\1 或者$1）。\neg:\n先来看第一个作用，对于IP地址的匹配，简单的可以写为如下形式：\n1 /\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3}/ 但仔细观察，我们可以发现一定的规律，可以把.\\d{1,3}看成一个整体，也就是把他们看成一组，再把这个组重复3次即可。表达式如下：\n1 /\\d{1,3}(.\\d{1,3}){3}/ 再来看第二个作用，就拿匹配\u0026lt;title\u0026gt;xxx\u0026lt;/title\u0026gt;标签来说，简单的正则可以这样写：\n1 /\u0026lt;title\u0026gt;.*\u0026lt;\\/title\u0026gt;/ 可以看出，上边表达式中有两个title，完全一样，其实可以通过分组简写。表达式如下：\n1 /\u0026lt;(title)\u0026gt;.*\u0026lt;\\/\\1\u0026gt;/ 对于分组而言，整个表达式永远算作第0组 在上述例中，第0组是\u0026lt;(title)\u0026gt;.*\u0026lt;/\\1\u0026gt;，然后从左到右，依次为分组编号，因此，(title)是第1组 :::warning 注意 用\\1这种语法，可以引用某组的文本内容，但不能引用正则表达式。 ::: 例如刚刚的IP地址正则表达式为\\d{1,3}(.\\d{1,3}){3}，里边的\\d{1,3}重复了两次，如果利用后向引用简化，表达式如下\n1 /(\\d{1,3})(.\\1){3}/ 经过实际测试，会发现这样写是错误的，为什么呢？\n后向引用，引用的仅仅是文本内容，而不是正则表达式！\n也就是说，组中的内容一旦匹配成功，后向引用，引用的就是匹配成功后的内容，引用的是结果，而不是表达式。\n因此，(\\d{1,3})(.\\1){3}这个表达式实际上匹配的是四个数都相同的IP地址，比如：123.123.123.123。\n不捕获 不捕获其实就是在分组的前边加上?:，可以在不需要捕获分组的表达式中使用，加快表达式执行速度。\n就拿匹配xxx标签来说，通过分组可以简写为\n1 /\u0026lt;(title)\u0026gt;.*\u0026lt;\\/\\1\u0026gt; / 但是如果是(?:title),则\\1就不能捕获到这个子组了，只能捕获第一个出现的非?:的分组作为\\1\n::: tip 提示 (?:title)本身会在完整匹配中，只是不在子组中，注意和断言的区别 :::\n断言 所谓断言，就是指明某个字符串前边或者后边，将会出现满足某种规律的字符串 就拿匹配\u0026lt;title\u0026gt;xxx\u0026lt;/title\u0026gt;标签来说 我们想要的是xxx，它没有规律，但是它前边肯定会有\u0026lt;title\u0026gt;,后边肯定会有\u0026lt;/title\u0026gt;，这就足够了 想指定xxx前肯定会出现\u0026lt;title\u0026gt;，就用正后发断言，表达式：\n1 /(?\u0026lt;=\u0026lt;title\u0026gt;).*/ 想指定xxx后边肯定会出现，就用正先行断言，表达式：\n1 /.*(?=\u0026lt;\\/title\u0026gt;)/ 两个加在一起，就是\n1 /(?\u0026lt;=\u0026lt;title\u0026gt;).*(?=\u0026lt;\\/title\u0026gt;)/ 对正后发和正先行的解释：\n其实掌握了规律，就很简单了，无论是先行还是后发，都是相对于xxx而言的，也就是相对于目标字符串而言。\n假如目标字符串后边有条件，可以理解为目标字符串在前，就用先行断言，放在目标字符串之后。\n假如目标字符串前边有条件，可以理解为目标字符串在后，就用后发断言，放在目标字符串之前。\n假如指定满足某个条件，就是正。\n假如指定不满足某个条件，就是负。\n断言只是条件，帮你找到真正需要的字符串，本身并不会匹配！\n！表示正好相反的意思，就是把=换成了！，看表格解释，X代表字符\n表达式 释义 (?=X ) 零宽度正先行断言。仅当子表达式 X 在 此位置的右侧匹配时才继续匹配。例如，\\w+(?=\\d) 与后跟数字的单词匹配，而不与该数字匹配。此构造不会回溯。 (?!X) 零宽度负先行断言。仅当子表达式 X 不在 此位置的右侧匹配时才继续匹配。例如，例如，\\w+(?!\\d) 与后不跟数字的单词匹配，而不与该数字匹配 。 (?\u0026lt;=X) 零宽度正后发断言。仅当子表达式 X 在 此位置的左侧匹配时才继续匹配。例如，(?\u0026lt;=19)99 与跟在 19 后面的 99 的实例匹配。此构造不会回溯。 (?\u0026lt;!X) 零宽度负后发断言。仅当子表达式 X 不在此位置的左侧匹配时才继续匹配。例如，(?\u0026lt;!19)99 与不跟在 19 后面的 99 的实例匹配 ","permalink":"https://mgso.site/front-end/reg/","summary":"分组 分组在正则中用()表示，分组的作用有两个：\n1.将某些规律看成是一组，然后进行组级别的重复，可以得到意想不到的效果。\n2.分组之后，可以通过后向引用简化表达式（\\1 或者$1）。\neg:\n先来看第一个作用，对于IP地址的匹配，简单的可以写为如下形式：\n1 /\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3}/ 但仔细观察，我们可以发现一定的规律，可以把.\\d{1,3}看成一个整体，也就是把他们看成一组，再把这个组重复3次即可。表达式如下：\n1 /\\d{1,3}(.\\d{1,3}){3}/ 再来看第二个作用，就拿匹配\u0026lt;title\u0026gt;xxx\u0026lt;/title\u0026gt;标签来说，简单的正则可以这样写：\n1 /\u0026lt;title\u0026gt;.*\u0026lt;\\/title\u0026gt;/ 可以看出，上边表达式中有两个title，完全一样，其实可以通过分组简写。表达式如下：\n1 /\u0026lt;(title)\u0026gt;.*\u0026lt;\\/\\1\u0026gt;/ 对于分组而言，整个表达式永远算作第0组 在上述例中，第0组是\u0026lt;(title)\u0026gt;.*\u0026lt;/\\1\u0026gt;，然后从左到右，依次为分组编号，因此，(title)是第1组 :::warning 注意 用\\1这种语法，可以引用某组的文本内容，但不能引用正则表达式。 ::: 例如刚刚的IP地址正则表达式为\\d{1,3}(.\\d{1,3}){3}，里边的\\d{1,3}重复了两次，如果利用后向引用简化，表达式如下\n1 /(\\d{1,3})(.\\1){3}/ 经过实际测试，会发现这样写是错误的，为什么呢？\n后向引用，引用的仅仅是文本内容，而不是正则表达式！\n也就是说，组中的内容一旦匹配成功，后向引用，引用的就是匹配成功后的内容，引用的是结果，而不是表达式。\n因此，(\\d{1,3})(.\\1){3}这个表达式实际上匹配的是四个数都相同的IP地址，比如：123.123.123.123。\n不捕获 不捕获其实就是在分组的前边加上?:，可以在不需要捕获分组的表达式中使用，加快表达式执行速度。\n就拿匹配xxx标签来说，通过分组可以简写为\n1 /\u0026lt;(title)\u0026gt;.*\u0026lt;\\/\\1\u0026gt; / 但是如果是(?:title),则\\1就不能捕获到这个子组了，只能捕获第一个出现的非?:的分组作为\\1\n::: tip 提示 (?:title)本身会在完整匹配中，只是不在子组中，注意和断言的区别 :::\n断言 所谓断言，就是指明某个字符串前边或者后边，将会出现满足某种规律的字符串 就拿匹配\u0026lt;title\u0026gt;xxx\u0026lt;/title\u0026gt;标签来说 我们想要的是xxx，它没有规律，但是它前边肯定会有\u0026lt;title\u0026gt;,后边肯定会有\u0026lt;/title\u0026gt;，这就足够了 想指定xxx前肯定会出现\u0026lt;title\u0026gt;，就用正后发断言，表达式：\n1 /(?\u0026lt;=\u0026lt;title\u0026gt;).*/ 想指定xxx后边肯定会出现，就用正先行断言，表达式：\n1 /.*(?=\u0026lt;\\/title\u0026gt;)/ 两个加在一起，就是\n1 /(?\u0026lt;=\u0026lt;title\u0026gt;).*(?=\u0026lt;\\/title\u0026gt;)/ 对正后发和正先行的解释：\n其实掌握了规律，就很简单了，无论是先行还是后发，都是相对于xxx而言的，也就是相对于目标字符串而言。\n假如目标字符串后边有条件，可以理解为目标字符串在前，就用先行断言，放在目标字符串之后。\n假如目标字符串前边有条件，可以理解为目标字符串在后，就用后发断言，放在目标字符串之前。\n假如指定满足某个条件，就是正。\n假如指定不满足某个条件，就是负。\n断言只是条件，帮你找到真正需要的字符串，本身并不会匹配！\n！表示正好相反的意思，就是把=换成了！，看表格解释，X代表字符\n表达式 释义 (?=X ) 零宽度正先行断言。仅当子表达式 X 在 此位置的右侧匹配时才继续匹配。例如，\\w+(?","title":"js正则表达式分组() 不捕获(?:) 断言"},{"content":"js中遍历的方法有很多,例如普通的for(;;),for in,while,forEach,some,map\u0026hellip;.等等. 本文主要介绍js中的for in循环和for of循环\nfor in for in的常见用法主要是用来遍历一个对象.例如\n1 2 3 4 5 var obj = {a:1,b:2,c:3}; for(var k in obj){ console.log(k) } //a b c 上述代码中for in通过遍历对象的键来实现输出对应value.也就是说for in 其实是遍历对象键 我们来试试遍历数组\n1 2 3 4 5 var arr = [1,2,3]; for(var k in arr){ console.log(k) } //0 1 2 其实这里和for(;;)循环挺像的.我们因为数组的索引在这里被看成了键.\n我们还是可以通过这个键去获取值例如这样\n1 2 3 4 5 var arr = [1,2,3]; for(var k in arr){ console.log(arr[k]) } //1 2 3 其实熟悉for in的同学都知道.数组是不能用for in来遍历的.因为不安全.\n有些时候我们可能需要给Array对象拓展一些函数或者属性,例如:\n1 2 3 4 5 6 7 8 Array.prototype.foo = function(){ //给数组原型上添加一个自定义函数 }; var arr = [1,2,3]; for(var i in arr){ console.log(i) } //0 1 2 foo 可以看到for in直接将我们拓展的函数一并给遍历出来了.看下MDN上的解释\n从图中我们看到一个名词可枚举属性.那么现在就可以介绍我们的for of\n在介绍for of 之前我们先来了解一下这个名词到底是什么\n可枚举属性 其实说得直白点.可枚举也就是说可以遍历出来\n\u0026ldquo;可以出现在对象属性的遍历中\u0026rdquo; (你不知道的JavaScript)\n这里呢,引出一个Object的函数Object.defineProperty():\n1 2 3 4 5 6 7 8 9 10 11 var obj = {a:1,b:2}; Object.defineProperty(obj,\u0026#39;c\u0026#39;,{ enumerable:false, value:3 }) obj.c //3 obj.hasOwnProperty(\u0026#39;c\u0026#39;); //true; for(var k in obj){ console.log(k) } //a b 上述代码我们只关心一个属性enumerable.如果将它赋值为false,那么这个属性将不可被枚举.也自然不可被遍历\n我们改一下之前用for in遍历数组的例子\n1 2 3 4 5 6 7 8 9 10 11 Object.defineProperty(Array,\u0026#39;foo\u0026#39;,{ enumerable:false, value:function(){ //给数组原型上添加一个自定义函数 } }); var arr = [1,2,3]; for(var i in arr){ console.log(i) } //0 1 2 可以看到我们可以通过Object.defineProperty()将enumerable设置成false,新增的foo就不会被遍历出来了.\n那么接下来就是es6中的for of方法了\nfor of for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name;\n还是之前for in遍历数组的例子.我们改写成for of遍历\n1 2 3 4 5 6 7 8 Array.prototype.foo = function(){ //给数组原型上添加一个自定义函数 }; var arr = [1,2,3]; for(var i of arr){ console.log(i) } //1 2 3 可以看到,尽管我们给Array拓展了一个foo函数,且没有设置其enumerable为false.也依然可以拿到对应的值.\n::: tip 提示 for of 是遍历元素,也就是value.而不是key :::\n那,for of 的内部实现到底是怎样的呢.这里延伸一个新知识点 iterator\niterator for of循环首先会向被访问对象请求一个迭代器对象,然后通过调用迭代器对象的next()方法来遍历所有返回值 (你不知道的JavaScript)\n上面之所以可以用for of遍历数组是因为数组有内置的iterator.在用for of遍历的时候回自动调用next()返回.\n那么我们手动来手动遍历一下:\n1 2 3 4 5 6 var arr = [1,2,3]; var it = arr[Symbol.iterator](); it.next();//{value:1,done:false} it.next();//{value:2,done:false} it.next();//{value:3,done:false} it.next();//{value:undefined,done:true} 不难看出.我们通过调用next()函数获取到了相应的value.直到返回对象中done为true;\n那for of可以用来遍历对象吗?\n1 2 3 4 5 var obj = {a:1,b:2,c:3}; for(var v of obj){ console.log(v); } //Uncaught TypeError: obj is not iterable 咦,报错了.回顾一下上面那句话for of循环首先会向被访问对象请求一个迭代器对象,上述例子中obj并没有这个iterable对象.所以不可用for of遍历\n那就不能用for of 遍历对象了吗?\n其实不然.我们只要给对象实现一个iterable即可. 看下面例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 var myObject = { a: 1, b: 2, c: 3 }; Object.defineProperty(myObject, Symbol.iterator, { enumerable: false, writable: false, configurable: true, value: function () { var o = this; var keys = Object.keys(o); //得到对象中所有key var i = 0;//迭代计数器 return { next: function () { return { value: o[keys[i++]], done: i \u0026gt; keys.length } } } } }); var it = myObject[Symbol.iterator](); it.next();//{value: 1, done: false} it.next();//{value: 2, done: false} it.next();//{value: 3, done: false} for (var v of myObject) { console.log(v) } //1 2 3 以上就是对for in for of的简单介绍以及延伸出的可枚举属性和iterator的介绍\n","permalink":"https://mgso.site/front-end/for/","summary":"js中遍历的方法有很多,例如普通的for(;;),for in,while,forEach,some,map\u0026hellip;.等等. 本文主要介绍js中的for in循环和for of循环\nfor in for in的常见用法主要是用来遍历一个对象.例如\n1 2 3 4 5 var obj = {a:1,b:2,c:3}; for(var k in obj){ console.log(k) } //a b c 上述代码中for in通过遍历对象的键来实现输出对应value.也就是说for in 其实是遍历对象键 我们来试试遍历数组\n1 2 3 4 5 var arr = [1,2,3]; for(var k in arr){ console.log(k) } //0 1 2 其实这里和for(;;)循环挺像的.我们因为数组的索引在这里被看成了键.\n我们还是可以通过这个键去获取值例如这样\n1 2 3 4 5 var arr = [1,2,3]; for(var k in arr){ console.log(arr[k]) } //1 2 3 其实熟悉for in的同学都知道.","title":"js中的for in for of"},{"content":"在移动端开发中,不同分辨率的设备所展示的样式也会不同.为了解决这一问题,我们用rem单位替换掉原来的px单位. 已达到移动端自适应的效果\nrem 先来简单了解一下rem.\nrem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。\n1 2 3 4 5 6 7 8 9 html{ font-size:20px; } .btn { width: 6rem; height: 3rem; line-height: 3rem; font-size: 1.2rem; } 如上述代码, html中设置了font-size为20px. 那么根据rem计算规则, .btn中的width:6rem 其实等价于width:120px; 也就是说现在的1rem = 20px. 那么之后我们在开发过程中只需使用rem作为基本单位即可.\n这里就会有个问题.我要如何知道根节点中font-size应该设置多少呢?\n设置根节点font-size 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //设置根节点font-size (function (doc, win) { var docEl = doc.documentElement, resizeEvt = \u0026#39;orientationchange\u0026#39; in window ? \u0026#39;orientationchange\u0026#39; : \u0026#39;resize\u0026#39;, recalc = function () { var rem = docEl.clientWidth / 10; if (!rem) return; docEl.style.fontSize = rem + \u0026#39;px\u0026#39;; }; recalc(); if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); //窗体大小发生改变时 doc.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, recalc, false);//文档重载时 })(document, window); 只需通过上面的代码.我们既可给html设置对应的font-size值.\n自动转换px为rem postcss-pxtorem 现在根节点的值设置好了,我们只需在开发过程中使用rem单位就可以实现自适应了,但是我们常用的是px单位.ui给出的设计稿也是px作为单位. 所以,我们需要一个将px转换为rem单位的东西postcss-pxtorem github地址\n这是一个css后置处理器,通过配置.可以将所有的px单位转换成rem. 以便于我们还是按照UI给的设计稿中的px单位进行开发,不用去考虑rem 的转换\nInstall 首先安装 postcss-pxtorem\n1 npm install postcss-pxtorem --save-dev vue-cli 配置 根目录下 配置.postcssrc.js文件\n1 2 3 4 5 6 7 8 9 10 11 module.exports = { \u0026#34;plugins\u0026#34;: { \u0026#34;postcss-pxtorem\u0026#34;: { \u0026#34;rootValue\u0026#34;: 37.5, \u0026#34;propList\u0026#34;: [\u0026#34;*\u0026#34;], // 注意：如果有使用第三方UI如VUX，则需要配置下忽略选择器不转换。 // 规则是class中包含的字符串，如vux中所有的class前缀都是weui-。也可以是正则。 \u0026#34;selectorBlackList\u0026#34;: [\u0026#34;vux-\u0026#34;, \u0026#39;van-\u0026#39;] } } } 配置完成后在css编写过程中,依旧使用px作为单位.pxtorem会自动帮我们转换. 如下图\n","permalink":"https://mgso.site/front-end/pxtorem/","summary":"在移动端开发中,不同分辨率的设备所展示的样式也会不同.为了解决这一问题,我们用rem单位替换掉原来的px单位. 已达到移动端自适应的效果\nrem 先来简单了解一下rem.\nrem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。\n1 2 3 4 5 6 7 8 9 html{ font-size:20px; } .btn { width: 6rem; height: 3rem; line-height: 3rem; font-size: 1.2rem; } 如上述代码, html中设置了font-size为20px. 那么根据rem计算规则, .btn中的width:6rem 其实等价于width:120px; 也就是说现在的1rem = 20px. 那么之后我们在开发过程中只需使用rem作为基本单位即可.\n这里就会有个问题.我要如何知道根节点中font-size应该设置多少呢?\n设置根节点font-size 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //设置根节点font-size (function (doc, win) { var docEl = doc.","title":"移动端自适应.px转rem"}]