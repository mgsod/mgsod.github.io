(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{189:function(t,e,s){"use strict";s.r(e);var a=s(0),v=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[s("h2",{attrs:{id:"分组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分组","aria-hidden":"true"}},[t._v("#")]),t._v(" 分组")]),t._v(" "),s("p",[t._v("分组在正则中用()表示，分组的作用有两个：")]),t._v(" "),s("p",[t._v("1.将某些规律看成是一组，然后进行组级别的重复，可以得到意想不到的效果。")]),t._v(" "),s("p",[t._v("2.分组之后，可以通过后向引用简化表达式（\\1 或者$1）。")]),t._v(" "),s("p",[s("strong",[t._v("eg:")])]),t._v(" "),s("p",[t._v("先来看第一个作用，对于IP地址的匹配，简单的可以写为如下形式：")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("    "),s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3}/")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("但仔细观察，我们可以发现一定的规律，可以把"),s("code",[t._v(".\\d{1,3}")]),t._v("看成一个整体，也就是把他们看成一组，再把这个组重复3次即可。表达式如下：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("    "),s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/\\d{1,3}(.\\d{1,3}){3}/")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("再来看第二个作用，就拿匹配"),s("code",[t._v("<title>xxx</title>")]),t._v("标签来说，简单的正则可以这样写：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("    "),s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/<title>.*<\\/title>/")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("可以看出，上边表达式中有两个title，完全一样，其实可以通过分组简写。表达式如下：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("    "),s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/<(title)>.*<\\/\\1>/")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[s("code",[t._v("对于分组而言，整个表达式永远算作第0组")]),t._v(" 在上述例中，第0组是<(title)>.*</\\1>，然后从左到右，依次为分组编号，因此，(title)是第1组")]),t._v(" "),s("div",{staticClass:"warning custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),s("p",[t._v("用\\1这种语法，可以引用某组的文本内容，但不能引用正则表达式。")])]),t._v(" "),s("p",[t._v("例如刚刚的IP地址正则表达式为"),s("code",[t._v("\\d{1,3}(.\\d{1,3}){3}")]),t._v("，里边的"),s("code",[t._v("\\d{1,3}")]),t._v("重复了两次，如果利用后向引用简化，表达式如下")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("    "),s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/(\\d{1,3})(.\\1){3}/")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("经过实际测试，会发现这样写是错误的，为什么呢？")]),t._v(" "),s("p",[s("code",[t._v("后向引用，引用的仅仅是文本内容，而不是正则表达式！")])]),t._v(" "),s("p",[s("code",[t._v("也就是说，组中的内容一旦匹配成功，后向引用，引用的就是匹配成功后的内容，引用的是结果，而不是表达式。")])]),t._v(" "),s("p",[t._v("因此，"),s("code",[t._v("(\\d{1,3})(.\\1){3}")]),t._v("这个表达式实际上匹配的是四个数都相同的IP地址，比如："),s("code",[t._v("123.123.123.123")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"不捕获"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不捕获","aria-hidden":"true"}},[t._v("#")]),t._v(" 不捕获")]),t._v(" "),s("p",[t._v("不捕获其实就是在分组的前边加上"),s("code",[t._v("?:")]),t._v("，可以在不需要捕获分组的表达式中使用，加快表达式执行速度。")]),t._v(" "),s("p",[t._v("就拿匹配")]),s("title",[t._v("xxx")]),t._v("标签来说，通过分组可以简写为"),s("p"),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("    "),s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/<(title)>.*<\\/\\1> /")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("但是如果是(?:title),则\\1就不能捕获到这个子组了，只能捕获第一个出现的非?:的分组作为\\1")]),t._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("(?:title)本身会在完整匹配中，只是不在子组中，注意和断言的区别")])]),t._v(" "),s("h2",{attrs:{id:"断言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#断言","aria-hidden":"true"}},[t._v("#")]),t._v(" 断言")]),t._v(" "),s("p",[s("code",[t._v("所谓断言，就是指明某个字符串前边或者后边，将会出现满足某种规律的字符串")]),t._v("\n就拿匹配"),s("code",[t._v("<title>xxx</title>")]),t._v("标签来说\n我们想要的是xxx，它没有规律，但是它前边肯定会有"),s("code",[t._v("<title>")]),t._v(",后边肯定会有"),s("code",[t._v("</title>")]),t._v("，这就足够了\n想指定xxx前肯定会出现"),s("code",[t._v("<title>")]),t._v("，就用正后发断言，表达式：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/(?<=<title>).*/")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("想指定xxx后边肯定会出现"),t._v("，就用正先行断言，表达式：")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/.*(?=<\\/title>)/")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("两个加在一起，就是")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/(?<=<title>).*(?=<\\/title>)/")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[s("strong",[t._v("对正后发和正先行的解释：")])]),t._v(" "),s("p",[t._v("其实掌握了规律，就很简单了，无论是先行还是后发，都是相对于xxx而言的，也就是相对于目标字符串而言。")]),t._v(" "),s("p",[t._v("假如目标字符串后边有条件，可以理解为目标字符串在前，就用先行断言，放在目标字符串之后。")]),t._v(" "),s("p",[t._v("假如目标字符串前边有条件，可以理解为目标字符串在后，就用后发断言，放在目标字符串之前。")]),t._v(" "),s("p",[t._v("假如指定满足某个条件，就是正。")]),t._v(" "),s("p",[t._v("假如指定不满足某个条件，就是负。")]),t._v(" "),s("p",[t._v("断言只是条件，帮你找到真正需要的字符串，本身并不会匹配！")]),t._v(" "),s("p",[s("strong",[t._v("！表示正好相反的意思，就是把=换成了！，看表格解释，X代表字符")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("表达式")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("释义")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("(?=X )")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("零宽度正先行断言。仅当子表达式 X 在 此位置的右侧匹配时才继续匹配。例如，\\w+(?=\\d) 与后跟数字的单词匹配，而不与该数字匹配。此构造不会回溯。")])]),t._v(" "),s("tr",[s("td",[t._v("(?!X)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("零宽度负先行断言。仅当子表达式 X 不在 此位置的右侧匹配时才继续匹配。例如，例如，\\w+(?!\\d) 与后不跟数字的单词匹配，而不与该数字匹配 。")])]),t._v(" "),s("tr",[s("td",[t._v("(?<=X)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("零宽度正后发断言。仅当子表达式 X 在 此位置的左侧匹配时才继续匹配。例如，(?<=19)99 与跟在 19 后面的 99 的实例匹配。此构造不会回溯。")])]),t._v(" "),s("tr",[s("td",[t._v("(?<!X)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("零宽度负后发断言。仅当子表达式 X 不在此位置的左侧匹配时才继续匹配。例如，(?<!19)99 与不跟在 19 后面的 99 的实例匹配")])])])])])}],!1,null,null,null);e.default=v.exports}}]);